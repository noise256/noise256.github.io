<!DOCTYPE html>

<html>
	<head>
		<title>Flocking</title>
		
		<meta charset="UTF-8"> 
		<LINK href="starlings.css" rel="stylesheet" type="text/css">
		
		<!-- <script src="js/sylvester.src.js" type="text/javascript"></script> -->
		<script src="js/common.js", type="text/javascript"></script>
		<script src="js/vec3.js", type="text/javascript"></script>
		<script src="js/fpsmeter.js" type="text/javascript"></script>
		<script src="js/three.min.js" type="text/javascript"></script>
		<script src="js/OrbitControls.js" type="text/javascript"></script>
	</head>
	
	<!-- Based on Three.js "Getting Started" tutorial. -->
	<body>
		<div id="WebGLCanvas"; style="margin:auto; text-align:center; width: 1000px; height: 800px; border:1px solid white;">
			<script>
				var canvasWidth = 1000;
				var canvasHeight = 800;
				
				/**
					FPS Meter
				*/
				var fpsMeter = new FPSMeter(document.body, { decimals: 0, graph: true, theme: 'dark', left: '5px' });
				var now;
				var dt = 0;
				var last = timestamp();
				var step = 1/60;
				
				/**
					THREE.js Objects 
				*/
				var scene;
				var renderer;
				var camera;
				var controls;
				
				var ambientLight;
				var mainLight;
				
				/**
					SPP Variable.
				*/
				var maxParticles = 250;
	
				var repulseStr = 1;
				var repulseRange = 5;
				
				var alignStr = 0.8;
				var alignRange = 5 + repulseRange;
				
				var attractStr = 1;
				var attractRange = 5 + alignRange + repulseRange;
				
				var walkStr = 250;
				
				var velocity = 0.1;
				
				var randWalkLUSize = 100;
				
				var randWalkLU = [];
				
				var particleSystem;
				
				/**
					THREE.js Functions
				*/
				
				window.onload=function(){
					createScene();
					initSPPModel();
					frame();
				};
				
				function update() {
					updateSPPModel();
					particleSystem.geometry.dynamic = true;
					particleSystem.geometry.verticesNeedUpdate = true;
				}
				
				function render() {
					renderer.render(scene, camera);
				}
				
				function frame() {
					fpsMeter.tickStart();
					
					requestAnimationFrame(frame);
					
					//now = timestamp();
					//dt = dt + Math.min(1, (now - last) / 1000);
					
					//while (dt > step) {
						//dt = dt - step;
						update();
					//}

					render();
					
					
					
					//last = now;
					fpsMeter.tick();
				};
				
				function timestamp() {
					if (window.performance && window.performance.now) {
						return window.performance.now();
					}
					else {
						return new Date().getTime();
					}
				}
				
				function createScene() {
					/**
						Scene.
					*/
					scene = new THREE.Scene();
					
					/**
						Camera.
					*/
					camera = new THREE.PerspectiveCamera(60, canvasWidth / canvasHeight, 0.1, 1000);				
					camera.position.x = 24;
					camera.position.y = 10;
					camera.position.z = 24;			
					camera.lookAt(new THREE.Vector3(0, 10, 0));
					
					/**
						Renderer.
					*/
					renderer = new THREE.WebGLRenderer();			
					renderer.setSize(canvasWidth, canvasHeight);
					document.getElementById("WebGLCanvas").appendChild(renderer.domElement);
					
					/**
						Controls.
					*/
					controls = new THREE.OrbitControls(camera);
					controls.target.y = 10;
					
					/**
						Lighting.
					*/
					ambientLight = new THREE.AmbientLight(0x404040);
					scene.add(ambientLight);
					
					mainLight = new THREE.PointLight();
					mainLight.position.set(50, 150, 150);
					scene.add(mainLight);
				
					/**
						Environment Objects.
					*/
					var groundGeometry = new THREE.PlaneGeometry(20, 20, 20, 20);
					var groundMaterial = new THREE.MeshBasicMaterial({color: 0xF7D480, wireframe: true});
					var groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
					groundMesh.rotation.x = -Math.PI/2;					
					scene.add(groundMesh);
				}
				
				/**
					SPP Model Functions.
				*/
				function initSPPModel() {
					/**
					Pregenerate random walk look up table.
					*/
					for (var i = 0; i < randWalkLUSize; i++) {
						//var theta = Math.random() * Math.PI * 2;
						//var mu = Math.random() < 0.5 ? Math.random() : -Math.random();
						
						//var vx = Math.sqrt(1 - Math.pow(mu, 2)) * Math.cos(theta),
						//	vy = Math.sqrt(1 - Math.pow(mu, 2)) * Math.sin(theta),
						//	vz = mu;
							
						//var vec = vec3.fromValues(vx,vy,vz);
						//vec3.normalize(vec, vec);
						
						//vec3.rotateX(vec, vec, vec3.create(), getGaussianAngle());
						//vec3.rotateY(vec, vec, vec3.create(), getGaussianAngle());
						//vec3.rotateZ(vec, vec, vec3.create(), getGaussianAngle());
						
						
						var rand = vec3.create();
						vec3.random(rand, getGaussianAngle());
						if (Math.random() < 0.5) {vec3.negate(rand, rand)};
						randWalkLU[i] = rand;
					}
					
					/**
					Generate particles.
					*/
					var particles = new THREE.Geometry();
					var pMaterial = new THREE.ParticleBasicMaterial( {size: 1, color: 0xffffff, map: THREE.ImageUtils.loadTexture("images/particle.png"), blending: THREE.AdditiveBlending, transparent: true} );
				
					for (i = 0; i < maxParticles; i++) {
						var particle = new THREE.Vector3(Math.random()*2, Math.random()*2+10, Math.random()*2);
						particle.velocity = new THREE.Vector3(0,0,0);
						
						particles.vertices.push(particle);//new THREE.Vector3(Math.random()*2, Math.random()*2+10, Math.random()*2));
					}
					
					particleSystem = new THREE.ParticleSystem(particles, pMaterial);
					
					particleSystem.sortParticles = true;
					scene.add(particleSystem);
				}
				
				function updateSPPModel() {
					var cParticle;
					var cVelocity;
					
					var sParticle;
					var sVelocity;
					
					var repulseVector;
					var alignVector;
					var attractVector;
					
					var siblingDist;
					var movement;
					
					for (var i = 0; i < maxParticles; i++) {
						cParticle = vec3.fromValues(particleSystem.geometry.vertices[i].x, particleSystem.geometry.vertices[i].y, particleSystem.geometry.vertices[i].z);
						cVelocity = vec3.fromValues(particleSystem.geometry.vertices[i].velocity.x, particleSystem.geometry.vertices[i].velocity.y, particleSystem.geometry.vertices[i].velocity.z);
						
						repulseVector = vec3.create();
						alignVector = vec3.create();
						attractVector = vec3.create();
						
						for (var j = 0; j < maxParticles; j++) {
							siblingDist = vec3.distance(sParticle, cParticle);
							
							if (siblingDist < attractRange) {
								sParticle = vec3.fromValues(particleSystem.geometry.vertices[j].x, particleSystem.geometry.vertices[j].y, particleSystem.geometry.vertices[j].z);
								if (siblingDist < alignRange) {
									if (siblingDist < repulseRange) {
										var sub = vec3.create();
										vec3.add(repulseVector, repulseVector, vec3.subtract(sub, cParticle, sParticle));
										continue;
									}
									sVelocity = vec3.fromValues(particleSystem.geometry.vertices[j].velocity.x, particleSystem.geometry.vertices[j].velocity.y, particleSystem.geometry.vertices[j].velocity.z);
									vec3.add(alignVector, alignVector, sVelocity);
									continue;
								}
								vec3.add(attractVector, attractVector, vec3.subtract(sub, sParticle, cParticle));
							}
						}
						
						movement = randWalkLU[Math.floor(Math.random() * randWalkLUSize)];
						vec3.scale(movement, movement, walkStr);
						
						vec3.scaleAndAdd(movement, movement, repulseVector, repulseStr);
						vec3.scaleAndAdd(movement, movement, attractVector, attractStr);
						vec3.scaleAndAdd(movement, movement, alignVector, alignStr);
						
						//todo cvelocity should be normalized already, its not, if 1st value of it is high then messed up
						vec3.normalize(movement, movement);
						vec3.add(cVelocity, cVelocity, movement);
						
						vec3.normalize(cVelocity, cVelocity);
						vec3.scaleAndAdd(cParticle, cParticle, cVelocity, velocity);

						particleSystem.geometry.vertices[i].set(cParticle[0], cParticle[1], cParticle[2]);
						particleSystem.geometry.vertices[i].velocity.set(cVelocity[0], cVelocity[1], cVelocity[2]);
					}
				}
				
				function getGaussianAngle() {
					var y = Math.PI * Math.exp(-(Math.random() * 5.0) / (2.0 * 2*2));
					return Math.random() < 0.5 ? y : -y;
				}
			</script>
		</div>
		
		<p style="margin:auto; text-align:center;">
			LMB: zoom, MMB: Pan, RB: Rotate. After some initial testing it appears that performance is substantially better in Chrome than in Firefox. More rigorous testing and optimisation will be done soon but for now I suggest using Google Chrome if you are having any performance issues.
		</p>
	</body>
</html>